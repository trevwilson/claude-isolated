#!/usr/bin/bash
# claude-isolated - Run Claude Code in an isolated git worktree

set -e

show_help() {
    cat << 'EOF'
Usage: claude-isolated [options] [claude args...]

Run Claude Code in an isolated git worktree. Changes don't affect
your main working directory until explicitly merged.

Options:
  -b <branch>   Base worktree on specified branch (must exist)
  -B <branch>   Base worktree on branch (create from HEAD if doesn't exist)
  -n <name>     Add a custom descriptor to the worktree name
  --code        Open VS Code in worktree instead of launching Claude
  --code-wait   Open VS Code and wait; show merge prompts when closed
  -l, --list    List existing worktrees and their status
  --prune       Remove stale worktree entries from ~/.claude.json
  -h, --help    Show this help message

Examples:
  claude-isolated                    # Use current branch
  claude-isolated -b main            # Use 'main' branch
  claude-isolated -B new-feature     # Create 'new-feature' if needed
  claude-isolated -n "api-work"      # Add descriptor to worktree name
  claude-isolated --resume           # Pass --resume to Claude
  claude-isolated --code             # Open VS Code, run claude manually
  claude-isolated --code-wait        # Open VS Code, merge prompts on close

Inside the session, run ./merge-worktree to merge changes back.
EOF
    exit 0
}

list_worktrees() {
    if [[ ! -d ".worktrees" ]]; then
        echo "No worktrees found"
        exit 0
    fi

    echo "Existing worktrees:"
    echo ""
    for dir in .worktrees/*/; do
        [[ -d "$dir" ]] || continue
        name=$(basename "$dir")

        # Get actual branch from worktree (not derived from directory name)
        branch=$(git -C "$dir" branch --show-current 2>/dev/null)
        if [[ -z "$branch" ]]; then
            branch="(detached HEAD)"
        fi

        # Check status
        status=""
        if git -C "$dir" diff --quiet 2>/dev/null && git -C "$dir" diff --cached --quiet 2>/dev/null; then
            # Check if merged
            source_branch=$(sed -n 's/^SOURCE_BRANCH="\([^"]*\)".*/\1/p' "$dir/merge-worktree" 2>/dev/null)
            source_branch="${source_branch:-unknown}"
            if git merge-base --is-ancestor "$branch" "$source_branch" 2>/dev/null; then
                status="merged"
            else
                status="unmerged"
            fi
        else
            status="uncommitted changes"
        fi

        printf "  %-40s  (%s)\n" "$name" "$status"
    done
    exit 0
}

prune_stale_projects() {
    if [[ ! -f "$HOME/.claude.json" ]]; then
        echo "No ~/.claude.json found"
        exit 0
    fi

    node -e "
        const fs = require('fs');
        const f = process.env.HOME + '/.claude.json';
        const d = JSON.parse(fs.readFileSync(f));
        let removed = 0;
        for (const p of Object.keys(d.projects || {})) {
            if (p.includes('/.worktrees/') && !fs.existsSync(p)) {
                delete d.projects[p];
                removed++;
                console.log('Removed:', p);
            }
        }
        if (removed) fs.writeFileSync(f, JSON.stringify(d, null, 2));
        console.log('Pruned', removed, 'stale worktree entries');
    "
    exit 0
}

# Must be in a git repo
git rev-parse --git-dir > /dev/null 2>&1 || { echo "Error: Not a git repo"; exit 1; }

# Parse flags
source_branch=""
custom_name=""
launch_mode="claude"  # claude, code, code-wait
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        -l|--list)
            list_worktrees
            ;;
        --prune)
            prune_stale_projects
            ;;
        --code)
            launch_mode="code"
            shift
            ;;
        --code-wait)
            launch_mode="code-wait"
            shift
            ;;
        -b)
            [[ -z "$2" ]] && { echo "Error: -b requires a branch name"; exit 1; }
            source_branch="$2"
            if ! git rev-parse --verify "$source_branch" > /dev/null 2>&1; then
                echo "Error: Branch '$source_branch' does not exist"
                echo "Use -B to create a new branch"
                exit 1
            fi
            shift 2
            ;;
        -B)
            [[ -z "$2" ]] && { echo "Error: -B requires a branch name"; exit 1; }
            source_branch="$2"
            if ! git rev-parse --verify "$source_branch" > /dev/null 2>&1; then
                echo "Creating branch '$source_branch' from HEAD..."
                git branch "$source_branch"
            fi
            shift 2
            ;;
        -n)
            [[ -z "$2" ]] && { echo "Error: -n requires a name"; exit 1; }
            custom_name="$2"
            shift 2
            ;;
        *)
            break  # Remaining args passed to claude
            ;;
    esac
done

# Capture current state
main_repo="$(pwd)"
source_branch="${source_branch:-$(git branch --show-current)}"

# Handle detached HEAD
if [[ -z "$source_branch" ]]; then
    echo "Error: Detached HEAD state - no branch checked out"
    echo "Use -b <branch> or -B <branch> to specify a branch"
    exit 1
fi

# Build readable ID: <branch>[-<custom>]-<YYYYMMDD-HHMM>
sanitized_branch="${source_branch//\//-}"  # Replace / with -
sanitized_name="${custom_name//[^a-zA-Z0-9_-]/-}"  # Keep only safe chars
timestamp="$(date +%Y%m%d-%H%M)"
if [[ -n "$sanitized_name" ]]; then
    id="${sanitized_branch}-${sanitized_name}-${timestamp}"
else
    id="${sanitized_branch}-${timestamp}"
fi
worktree_branch="claude-session/$id"
worktree_dir=".worktrees/$id"

# Ensure .worktrees is gitignored
if ! grep -q "^\.worktrees/$" .gitignore 2>/dev/null; then
    echo ".worktrees/" >> .gitignore
    echo "Added .worktrees/ to .gitignore"
fi

# Create worktree
git worktree add "$worktree_dir" -b "$worktree_branch" "$source_branch" --quiet
echo "Created isolated worktree: $worktree_dir"
echo "Source branch: $source_branch"

# Copy .claude folder for permissions/settings
# Remove first to avoid nesting if worktree already has .claude from git
if [[ -d "$main_repo/.claude" ]]; then
    rm -rf "$worktree_dir/.claude"
    cp -r "$main_repo/.claude" "$worktree_dir/.claude"
fi

# Create merge helper script
cat > "$worktree_dir/merge-worktree" << 'SCRIPT'
#!/bin/bash
set -e

MAIN_REPO="__MAIN_REPO__"
SOURCE_BRANCH="__SOURCE_BRANCH__"
WORKTREE_BRANCH="__WORKTREE_BRANCH__"

# Sanity check: verify we're on the expected branch
actual_branch=$(git branch --show-current)
if [[ "$actual_branch" != "$WORKTREE_BRANCH" ]]; then
    echo "Error: Expected branch $WORKTREE_BRANCH"
    echo "       But currently on $actual_branch"
    echo ""
    echo "Did you checkout a different branch in this worktree?"
    echo "The merge-worktree script is gitignored and won't update on checkout."
    exit 1
fi

# Commit any pending changes
if ! git diff --quiet || ! git diff --cached --quiet; then
    msg="${1:-Claude session changes}"
    git add -A
    git commit -m "$msg"
    echo "Committed pending changes"
fi

# Merge source branch INTO worktree (conflicts resolved here)
echo "Merging $SOURCE_BRANCH into worktree..."
if ! git merge "$SOURCE_BRANCH" --no-edit; then
    echo ""
    echo "=========================================="
    echo "  CONFLICTS DETECTED"
    echo "  Resolve them, then run:"
    echo "  git add -A && git commit && ./merge-worktree"
    echo "=========================================="
    exit 1
fi

# Verify fast-forward is possible
if ! git -C "$MAIN_REPO" merge-base --is-ancestor "$SOURCE_BRANCH" "$WORKTREE_BRANCH"; then
    echo ""
    echo "=========================================="
    echo "  CANNOT FAST-FORWARD"
    echo "  $SOURCE_BRANCH has diverged from this worktree."
    echo "  Pull latest changes: git merge $SOURCE_BRANCH"
    echo "  Then run ./merge-worktree again"
    echo "=========================================="
    exit 1
fi

# Fast-forward source branch (works regardless of what's checked out in main repo)
echo "Fast-forwarding $SOURCE_BRANCH..."
git -C "$MAIN_REPO" branch -f "$SOURCE_BRANCH" "$WORKTREE_BRANCH"

echo ""
echo "Merged into $SOURCE_BRANCH successfully"
SCRIPT

# Replace placeholders
sed -i "s|__MAIN_REPO__|$main_repo|g" "$worktree_dir/merge-worktree"
sed -i "s|__SOURCE_BRANCH__|$source_branch|g" "$worktree_dir/merge-worktree"
sed -i "s|__WORKTREE_BRANCH__|$worktree_branch|g" "$worktree_dir/merge-worktree"
chmod +x "$worktree_dir/merge-worktree"

# Launch based on mode
echo ""
echo "Run ./merge-worktree to merge changes back to $source_branch"

case "$launch_mode" in
    code)
        echo "Opening VS Code..."
        code "$worktree_dir"
        echo ""
        echo "When done, run ./merge-worktree from the worktree."
        echo "To clean up: git worktree remove $worktree_dir --force && git branch -D $worktree_branch"
        exit 0
        ;;
    code-wait)
        echo "Opening VS Code (will prompt for merge when closed)..."
        code --wait "$worktree_dir"
        exit_code=$?
        ;;
    claude)
        echo "Starting Claude..."
        echo ""
        cd "$worktree_dir"
        claude "$@"
        exit_code=$?
        ;;
esac

# Post-session prompt (code-wait and claude modes)
cd "$main_repo"
echo ""

# Check if already merged
if git merge-base --is-ancestor "$worktree_branch" "$source_branch" 2>/dev/null; then
    echo "Changes already merged to $source_branch"
else
    # Check for uncommitted changes
    if ! git -C "$worktree_dir" diff --quiet 2>/dev/null || \
       ! git -C "$worktree_dir" diff --cached --quiet 2>/dev/null; then
        echo "Worktree has uncommitted changes"
    fi

    read -p "Merge remaining changes to $source_branch? [y/N] " answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        (cd "$worktree_dir" && ./merge-worktree)
    fi
fi

read -p "Remove worktree and temp branch? [Y/n] " cleanup
if [[ ! "$cleanup" =~ ^[Nn]$ ]]; then
    # Get absolute path before removing worktree
    worktree_abs_path=$(realpath "$worktree_dir" 2>/dev/null || echo "")

    git worktree remove "$worktree_dir" --force 2>/dev/null || true
    git branch -D "$worktree_branch" 2>/dev/null || true

    # Remove worktree project from Claude's config to avoid polluting ~/.claude.json
    if [[ -n "$worktree_abs_path" && -f "$HOME/.claude.json" ]]; then
        node -e "
            const fs = require('fs');
            const f = process.env.HOME + '/.claude.json';
            const d = JSON.parse(fs.readFileSync(f));
            delete d.projects['$worktree_abs_path'];
            fs.writeFileSync(f, JSON.stringify(d, null, 2));
        " 2>/dev/null || true
    fi

    echo "Cleaned up"
fi

exit $exit_code
