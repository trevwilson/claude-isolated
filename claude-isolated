#!/usr/bin/bash
# claude-isolated - Run Claude Code in an isolated git worktree

set -e

show_help() {
    cat << 'EOF'
Usage: claude-isolated [options] [claude args...]

Run Claude Code in an isolated git worktree. Changes don't affect
your main working directory until explicitly merged.

Options:
  -b <branch>   Base worktree on specified branch (must exist)
  -B <branch>   Base worktree on branch (create from HEAD if doesn't exist)
  -n <name>     Add a custom descriptor to the worktree name
  -l, --list    List existing worktrees and their status
  -h, --help    Show this help message

Examples:
  claude-isolated                    # Use current branch
  claude-isolated -b main            # Use 'main' branch
  claude-isolated -B new-feature     # Create 'new-feature' if needed
  claude-isolated -n "api-work"      # Add descriptor to worktree name
  claude-isolated --resume           # Pass --resume to Claude

Inside the session, run ./merge-worktree to merge changes back.
EOF
    exit 0
}

list_worktrees() {
    if [[ ! -d ".worktrees" ]]; then
        echo "No worktrees found"
        exit 0
    fi

    echo "Existing worktrees:"
    echo ""
    for dir in .worktrees/*/; do
        [[ -d "$dir" ]] || continue
        name=$(basename "$dir")
        branch="claude-session/$name"

        # Check status
        status=""
        if git -C "$dir" diff --quiet 2>/dev/null && git -C "$dir" diff --cached --quiet 2>/dev/null; then
            # Check if merged
            source_branch=$(sed -n 's/^SOURCE_BRANCH="\([^"]*\)".*/\1/p' "$dir/merge-worktree" 2>/dev/null)
            source_branch="${source_branch:-unknown}"
            if git merge-base --is-ancestor "$branch" "$source_branch" 2>/dev/null; then
                status="merged"
            else
                status="unmerged"
            fi
        else
            status="uncommitted changes"
        fi

        printf "  %-40s  (%s)\n" "$name" "$status"
    done
    exit 0
}

# Must be in a git repo
git rev-parse --git-dir > /dev/null 2>&1 || { echo "Error: Not a git repo"; exit 1; }

# Parse flags
source_branch=""
custom_name=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        -l|--list)
            list_worktrees
            ;;
        -b)
            [[ -z "$2" ]] && { echo "Error: -b requires a branch name"; exit 1; }
            source_branch="$2"
            if ! git rev-parse --verify "$source_branch" > /dev/null 2>&1; then
                echo "Error: Branch '$source_branch' does not exist"
                echo "Use -B to create a new branch"
                exit 1
            fi
            shift 2
            ;;
        -B)
            [[ -z "$2" ]] && { echo "Error: -B requires a branch name"; exit 1; }
            source_branch="$2"
            if ! git rev-parse --verify "$source_branch" > /dev/null 2>&1; then
                echo "Creating branch '$source_branch' from HEAD..."
                git branch "$source_branch"
            fi
            shift 2
            ;;
        -n)
            [[ -z "$2" ]] && { echo "Error: -n requires a name"; exit 1; }
            custom_name="$2"
            shift 2
            ;;
        *)
            break  # Remaining args passed to claude
            ;;
    esac
done

# Capture current state
main_repo="$(pwd)"
source_branch="${source_branch:-$(git branch --show-current)}"

# Handle detached HEAD
if [[ -z "$source_branch" ]]; then
    echo "Error: Detached HEAD state - no branch checked out"
    echo "Use -b <branch> or -B <branch> to specify a branch"
    exit 1
fi

# Build readable ID: <branch>[-<custom>]-<YYYYMMDD-HHMM>
sanitized_branch="${source_branch//\//-}"  # Replace / with -
sanitized_name="${custom_name//[^a-zA-Z0-9_-]/-}"  # Keep only safe chars
timestamp="$(date +%Y%m%d-%H%M)"
if [[ -n "$sanitized_name" ]]; then
    id="${sanitized_branch}-${sanitized_name}-${timestamp}"
else
    id="${sanitized_branch}-${timestamp}"
fi
worktree_branch="claude-session/$id"
worktree_dir=".worktrees/$id"

# Ensure .worktrees is gitignored
if ! grep -q "^\.worktrees/$" .gitignore 2>/dev/null; then
    echo ".worktrees/" >> .gitignore
    echo "Added .worktrees/ to .gitignore"
fi

# Create worktree
git worktree add "$worktree_dir" -b "$worktree_branch" "$source_branch" --quiet
echo "Created isolated worktree: $worktree_dir"
echo "Source branch: $source_branch"

# Create merge helper script
cat > "$worktree_dir/merge-worktree" << 'SCRIPT'
#!/bin/bash
set -e

MAIN_REPO="__MAIN_REPO__"
SOURCE_BRANCH="__SOURCE_BRANCH__"
WORKTREE_BRANCH="__WORKTREE_BRANCH__"

# Commit any pending changes
if ! git diff --quiet || ! git diff --cached --quiet; then
    msg="${1:-Claude session changes}"
    git add -A
    git commit -m "$msg"
    echo "Committed pending changes"
fi

# Merge source branch INTO worktree (conflicts resolved here)
echo "Merging $SOURCE_BRANCH into worktree..."
if ! git merge "$SOURCE_BRANCH" --no-edit; then
    echo ""
    echo "=========================================="
    echo "  CONFLICTS DETECTED"
    echo "  Resolve them, then run:"
    echo "  git add -A && git commit && ./merge-worktree"
    echo "=========================================="
    exit 1
fi

# Now fast-forward source branch to include our work
echo "Fast-forwarding $SOURCE_BRANCH..."
git -C "$MAIN_REPO" merge "$WORKTREE_BRANCH" --ff-only

echo ""
echo "Merged into $SOURCE_BRANCH successfully"
SCRIPT

# Replace placeholders
sed -i "s|__MAIN_REPO__|$main_repo|g" "$worktree_dir/merge-worktree"
sed -i "s|__SOURCE_BRANCH__|$source_branch|g" "$worktree_dir/merge-worktree"
sed -i "s|__WORKTREE_BRANCH__|$worktree_branch|g" "$worktree_dir/merge-worktree"
chmod +x "$worktree_dir/merge-worktree"

# Launch claude in worktree
cd "$worktree_dir"
echo ""
echo "Run ./merge-worktree to merge changes back to $source_branch"
echo "Starting Claude..."
echo ""

claude "$@"
exit_code=$?

# Post-session prompt
cd "$main_repo"
echo ""

# Check if already merged
if git merge-base --is-ancestor "$worktree_branch" "$source_branch" 2>/dev/null; then
    echo "Changes already merged to $source_branch"
else
    # Check for uncommitted changes
    if ! git -C "$worktree_dir" diff --quiet 2>/dev/null || \
       ! git -C "$worktree_dir" diff --cached --quiet 2>/dev/null; then
        echo "Worktree has uncommitted changes"
    fi

    read -p "Merge remaining changes to $source_branch? [y/N] " answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
        (cd "$worktree_dir" && ./merge-worktree)
    fi
fi

read -p "Remove worktree and temp branch? [Y/n] " cleanup
if [[ ! "$cleanup" =~ ^[Nn]$ ]]; then
    git worktree remove "$worktree_dir" --force 2>/dev/null || true
    git branch -D "$worktree_branch" 2>/dev/null || true
    echo "Cleaned up"
fi

exit $exit_code
